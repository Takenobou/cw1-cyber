# Cyber Security Assignment 1

## Client-server architecture, public and private keys
The system consists of a client and a server Java program, and they must be named `Client.java` and `Server.java` respectively. They are started by running the commands
`java Server port`
`java Client host port userid`
specifying the hostname and port number of the server, and the userid of the client.

The server is a temporary store for all the messages sent by agents that are not yet read by their recipients. The server program is always running once started, and listens for incoming connections at the port specified. When a client is connected, the server handles the request, then waits for the next request (i.e., the server never terminates). For simplicity, you can assume that only one client will connect to the server at any one time.

The secret agents are users of the client program. Each agent has a unique userid, which is a simple string like alice, bob etc. The server has userid "server". Each agent, as well as the server, is associated with a pair of RSA public and private keys, with filenames that have .pub or .prv after the userid, respectively. Thus the key files are named `alice.pub`, `server.prv`, etc. These keys are generated separately by a program RSAKeyGen.java. More details are in the comments of that program.

It is assumed that the server already has its own private key and the public keys of all agents, and each agent already has their own private key as well as the public key of the server. They obtained these keys via some separate mechanism not described here, prior to the execution of the client and server programs, and is not part of these programs. **The client and server programs never create any new keys or distribute them.** Note that an agent does not have the public key of the other agents (e.g., alice does not have the public key of bob); in fact they probably don't know the true identity of each other. The secret agency that they work for do not want them to have secret communications among themselves.

All the key files are in the same folder where the respective client/server program runs from. They must not be read from other folders. Your programs must not require keys that they are not supposed to have.
## Messages, encryption, authentication and hashing
Whenever encryption is mentioned below, it means using the `RSA/ECB/PKCS1Padding` algorithm, with the appropriate public/private keys generated by `RSAKeyGen.java`. Exactly which one is the "appropriate" key may not be spelt out in the assignment specification below; it is part of the learning outcomes being assessed in this assignment.

You can assume the message to be encrypted is short enough so it can be encrypted by RSA (of the given key size) in one block.

Whenever signature is mentioned below, it means using the `SHA256withRSA` algorithm with the appropriate key from the same set of public/private RSA keys (RSA keys can also be used for signatures; in this system the same set of RSA keys are used for both encryption and signature purposes.) Again, exactly which is the "appropriate" key may not be spelt out explicitly.

The server is an intermediary between the agents who don't have each other's public keys (and hence cannot encrypt for each other directly). When A wants to send a message intended for B, A encrypts it with the server's public key (and not B's public key, since A doesn't have it). When the server receives such an encrypted message, it decrypts it with the appropriate key, and re-encrypts it with B's public key, before storing it locally. In other words, the server keeps the stored messages in encrypted form (ready to be sent to the recipient). This way, if the server is compromised the messages are still secure.

Whenever hashing of userid is mentioned below, it means applying the MD5 algorithm to a string formed by prepending a secret string "`gfhk2024:`" to the userid, and then converting to hexadecimal. For example, if the userid is alice, the hashed userid is
`hex(MD5("gfhk2024:alice"))`
which is
`9f0a1765d9e72468b874eb0f749b5a9d`

The system tries to offer some degree of anonymity. The sender userid of a message are not stored (the sender can include it in the message itself, if they wish to). For the recipient userid, when the client sends a message to the server, the recipient userid is encrypted alongside the message, and the server has to decrypt the message first to find out who the recipient is. But then the server computes the hashed recipient userid and only uses it to for storing and locating their saved messages; the unhashed recipient userid is discarded and not stored.
Each message also comes with an unencrypted timestamp. You are free to use whatever ways to represent a timestamp (for example, the `java.util.Date` object).

## The communication protocol
Initially, when the server is just started, it has no messages. For simplicity, you can assume the server only holds the messages in memory, i.e. there are no persistent storage of these messages (so when the server program quits, all messages are lost). You can hold these messages in any data structure you want.

When the client program starts, it first sends the hashed userid of this agent to the server. The server uses this to find out how many of its saved messages are for this user. It sends this number (which can be zero) to the client.

If this number is not zero, then for each such message, the server generates a signature based on its encrypted content and timestamp, with a key that proves the identity of the server. It sends the message (encrypted content and timestamp) and the signature to the client. The message is deleted from the server afterwards.

Upon receiving these contents, the client should first verify the signature with the appropriate key. If the key does not verify, it should terminate the connection immediately. Otherwise, it decrypts the message with the appropriate key, and displays the decrypted message and the timestamp on screen.

After displaying all these messages, the client program then asks the user whether they want to send a message. If the user does not want to, then the program ends. Otherwise, the client program prompts the user to enter the recipient userid, and the message. It concatenates the recipient userid with the message (you can insert some separator symbol between them), then encrypts it with RSA. Then it generates a signature based on the encryption result and a timestamp, with an appropriate key to prove the identity of this sender. The encrypted content, the timestamp, the signature, and the unhashed sender userid are sent to the server. (It is only at this point that the server knows the sender's unhashed userid, which it needs because it needs to verify this sender's identity.)

Only one message is sent; the client program ends afterwards. (If the user wants to send multiple messages they have to run the client program again.)

Upon receiving these contents, the server first verifies the signature with the appropriate key. If the signature does not verify, or if the sender userid is unrecognised (no corresponding key of that userid is present in the server), the message is discarded. Otherwise, it decrypts the message, and finds out the recipient userid. If the decryption fails (i.e., it results in a `BadPaddingException`), the message is again discarded. The server then re-encrypts the message (but without the recipient userid). Finally the server computes the hashed recipient userid, and saves it and the encrypted message to its collection of messages. The original (unhashed) recipient userid is not stored. The signature is also not stored.

The connection then ends and the server should wait for the next client. The server should not quit or terminate (even if the signature check fails or the client terminated their connection early).
